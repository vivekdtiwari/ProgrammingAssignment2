#library MASS has functions for matrix manipulation. Here only the function ginv()
#from this library is used to calculate inverse. Using alternative - solve()
#throws error if singular matrix is passed.
library(MASS)

#makeCacheMatrix is a function which returns a list of 4 functions as follows:
# 1.set :- function to set the value of matrix
# 2.get :- function to get the value of matrix
# 3.setInverse :- function to set the value of inverse
# 4.getInverse :- function to get the value of inverse

makeCacheMatrix <- function(x=matrix()) {
  inv <- NULL
  set <- function(y) {
    x <<- y
    inv <<- NULL
  }
  get <- function() x
  setInverse <- function(matInverse) inv <<- matInverse
  getInverse <- function() inv
  list(set = set, get = get, setInverse = setInverse, getInverse = getInverse)
}


#cacheSolve is the function which takes in the list of functions generated by makeCacheMatrix
#Here first we check if inverse already exists, if not then it is calculated.
#If inverse exists then message is printed "getting cached data"

cacheSolve <- function(x, ...){
  inv <- x$getInverse()
  if(!is.null(inv)) {
    message("getting cached data")
    return(inv)
  }
  data <- x$get()
  inv <- ginv(data)
  x$setInverse(inv)
  inv
}

#testing the scenario
values <- c(-1,0,-5,3,-6,-3,-3,5,1);
m <- matrix(values, nrow = 3, ncol = 3, byrow = T)
testScenario <- makeCacheMatrix(m)
#now testScenario contains the list of functions returned by makeCacheMatrix
#we will pass this to cacheSolve twice.
#First time as expected the value will be calculated.
#Second time it will print message and fetch the value from cache as no change in matrix.
cacheSolve(testScenario)
cacheSolve(testScenario)